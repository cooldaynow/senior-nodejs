# **ПЛАН ИЗУЧЕНИЯ NODE.JS ДО УРОВНЯ SENIOR И ВЫШЕ**

## **1. Глубокий Node.js и асинхронность**

### **1.1. Event Loop, асинхронность и внутренности Node.js**

1. **V8 и интерпретация кода**
    - Понимание: AST (Abstract Syntax Tree), JIT-компиляторы (Ignition, TurboFan), оптимизации.
    - Как JS-код превращается в машинный, что даёт возможность повышать производительность.
2. **Garbage Collector в V8**
    - Типы GC: Mark-and-Sweep, Incremental, Generational, Concurrent.
    - “Стоп-мир” (Stop-the-world) фазы, утечки памяти в Node.js и способы их выявить (heapdump, DevTools).
3. **Libuv и управление потоками**
    - Асинхронные I/O операции, Thread Pool для I/O-bound задач.
    - Ограничения при CPU-bound нагрузках.
4. **Фазы Event Loop**
    - Timers, I/O Callbacks, Idle/Prepare, Poll, Check, Close.
    - Разница между `setTimeout`, `setImmediate`, `process.nextTick`.
5. **Worker Threads**
    - Полноценная многопоточность в Node.js, отличие от Thread Pool libuv.
    - Передача данных между Worker’ами.

> **Задача**:
> - Сделать скрипт, который вычисляет факториал больших чисел в Worker Thread (не блокирует основной поток).
> - Проанализировать его работу с помощью флагов профилирования V8 (`--trace-opt`) и посмотреть на сборку мусора.

---

### **1.2. Модули в Node.js**

1. **CommonJS vs ES Modules**
    - `require` vs `import`, плюсы/минусы, когда использовать ESM.
2. **Кэширование модулей**
    - Как работает `require()`, единый инстанс модуля, ручной сброс кэша.
3. **Динамический импорт**
    - `import()` для lazy loading и плагинов.

> **Задача**:
> - Переписать небольшой проект на ESM, сохранив совместимость с CommonJS.
> - Реализовать механизм загрузки плагинов (роуты, хендлеры) “на лету” через `import()`.

---

### **1.3. Потоки (Streams) и работа с файлами**

1. **Концепция потоков**
    - Зачем нужны Streams, экономия памяти при обработке больших файлов.
2. **Типы потоков**
    - Readable (чтение), Writable (запись), Duplex (двунаправленный), Transform (преобразование).
    - Применение: чтение/запись файлов, HTTP-запросы, TCP-соединения, шифрование и сжатие “на лету”.
3. **Pipe и Backpressure**
    - `.pipe()` для подключения потоков друг к другу.
    - Решение проблемы Backpressure (управление скоростью чтения/записи).

> **Задача**:
> - Реализовать Transform-поток, который шифрует данные перед записью в файл.
> - Сделать загрузку/выгрузку больших файлов через HTTP без превышения по памяти, используя Pipe.

---

### **1.4. Промисы и async/await**

1. **Основы промисов**
    - `Promise.resolve`, `Promise.reject`, `Promise.all`, `Promise.race`, `Promise.any`.
    - Цепочки `.then`, `.catch`, `.finally`.
2. **Async/Await**
    - Упрощение работы с асинхронностью, `try/catch` и `.catch()`, глобальные `unhandledRejection`.
3. **Проблемы и ограничения**
    - Почему промисы нельзя «отменять», когда лучше Worker Threads.
    - Организация тайм-аутов для промисов.

> **Задача**:
> - Написать middleware (Express или Koa), которое глобально обрабатывает все async-ошибки.
> - Реализовать функцию, которая прерывает промис по тайм-ауту (например, «если задача не закончится за 5 секунд —
    отменяем»).

---

### **1.5. TypeScript**

1. **Зачем TypeScript**
    - Типобезопасность, автодополнение, упрощение рефакторинга.
2. **Основы**
    - Интерфейсы, типы (type), generics, enum.
3. **Продвинутая типизация**
    - Conditional Types, Utility Types (Partial, Pick, Omit, Required), Mapped Types.
4. **Интеграция**
    - Настройка `tsconfig.json`, декларирование типов (DefinitelyTyped), синхронизация с Node.js API.

> **Задача**:
> - Переписать небольшой сервис (CRUD) на TypeScript, обеспечив 100% типизацию.
> - Использовать generics и mapped types для гибкой работы с сущностями.

---

### **1.6. Продвинутая инструментализация (async_hooks, perf_hooks)**

1. **async_hooks**
    - Отслеживание цикла жизни асинхронных ресурсов, создание контекста запросов.
2. **perf_hooks**
    - Замеры производительности, время ответа, метрики.
3. **Дополнительные инструменты профилирования**
    - `clinic.js` (Doctor, Flame, Bubbleprof), `0x` для flamegraphs, Chrome DevTools.

> **Задача**:
> - Сделать middleware с использованием async_hooks, которое добавляет уникальный request-id и прокидывает его в логи.
> - Создать flamegraph (через `clinic flame` или `0x`) и оптимизировать “горячие точки”.

---

## **2. Архитектура крупных систем**

### **2.1. REST API и его оптимизация**

1. **Проектирование REST API**
    - Принципы REST, уровни зрелости (Richardson Maturity Model).
    - Версионирование API (v1, v2).
2. **Оптимизация запросов**
    - HTTP/2 (мультиплексирование, сжатие заголовков).
    - Кэширование (ETag, Last-Modified, Cache-Control).
3. **Rate Limiting и защита от DDoS**
    - `express-rate-limit`, Redis, NGINX.

> **Задача**:
> - Создать REST API (например, для управления пользователями) с версионированием.
> - Добавить поддержку ETag и протестировать поведение клиентов с 304 Not Modified.
> - Настроить лимиты на количество запросов в минуту.

---

### **2.2. GraphQL**

1. **Основы GraphQL**
    - Query, Mutation, Subscription.
    - Сравнение с REST (гибкость, сокращение «прогонов»).
2. **Оптимизация**
    - Избежание N+1 с помощью DataLoader.
    - Persisted Queries.

> **Задача**:
> - Реализовать GraphQL-сервер (например, на Apollo) для CRUD задач (TODO-list).
> - Подключить DataLoader, чтобы сократить лишние запросы к базе.

---

### **2.3. WebSockets и SSE**

1. **WebSockets**
    - Полнодуплексная связь, `ws`, `socket.io`.
    - Реализация чата или коллаборативного приложения.
2. **Server-Sent Events (SSE)**
    - Односторонний стрим данных от сервера к клиенту.

> **Задача**:
> - Написать мини-чат-приложение на WebSockets (публичные комнаты и приватные сообщения).
> - Реализовать SSE для уведомлений (например, рассылка статусов заказов).

---

### **2.4. Микросервисная архитектура**

1. **Монолит vs Микросервисы**
    - Когда микросервисы оправданы, основные паттерны (API Gateway, Service Discovery).
2. **Взаимодействие микросервисов**
    - Синхронное (REST, gRPC), асинхронное (Pub/Sub через Kafka, NATS, RabbitMQ).
3. **Построение**
    - API Gateway для входящих запросов, а сзади несколько сервисов.

> **Задача**:
> - Разработать 2–3 микросервиса (пользователи, заказы, платежи) + API Gateway.
> - Настроить взаимодействие через NATS (Pub/Sub) или Kafka.

---

### **2.5. Тестирование и CI/CD**

1. **Тестирование**
    - Модульные тесты (Jest/Mocha), интеграционные (Supertest), Mocking (Sinon).
    - Целевые показатели coverage (80%+).
2. **CI/CD**
    - GitHub Actions, GitLab CI, Jenkins: автоматический прогон тестов, линтинга, сборки.
    - CD: деплой по пушу в main, откат при ошибках.
3. **Обсервабилити**
    - Логирование (Winston, Pino), мониторинг (Prometheus, Grafana), трассировка (Jaeger, Zipkin).

> **Задача**:
> - Покрыть тестами ключевые сервисы (юнит + интеграция).
> - Настроить CI-пайплайн, который билдит приложение и выкатывает его на staging/production.
> - Подключить Prometheus к Node.js (экспорт метрик), отобразить в Grafana.

---

### **2.6. Docker и Kubernetes**

1. **Docker**
    - Создание Dockerfile: multi-stage build, оптимизация образов.
    - `docker-compose`: локальное окружение (Node + Redis + БД).
    - Регистри (Docker Hub, GHCR).
2. **Kubernetes**
    - Основные объекты: Pod, Deployment, Service, Ingress, ConfigMap, Secret.
    - Масштабирование: HPA (Horizontal Pod Autoscaler), Rolling Update.
    - Helm Charts: упаковка манифестов, templating, values.
3. **DevOps-практики**
    - GitOps (ArgoCD, Flux), Terraform/Pulumi для IaC.
    - CI/CD в контексте K8s: авторазвёртывание, управление конфигурациями.

> **Задача**:
> - Упаковать микросервисы в Docker-образы, собрать через docker-compose.
> - Задеплоить в Kubernetes (Deployment + Service + Ingress).
> - Настроить Helm Chart и автодеплой через GitHub Actions.

---

### **2.7. DDD (Domain-Driven Design) и Advanced Patterns**

1. **Основные принципы DDD**
    - Ubiquitous Language, Bounded Context, Entities, Value Objects, Repositories.
    - Контейнеризация доменной логики, стратегические/тактические паттерны.
2. **CQRS + Event Sourcing** (при желании)
    - Разделение операций на чтение/запись, хранение событий вместо состояний.
3. **Design Patterns**
    - (Factory, Adapter, Strategy, Observer, Decorator, Proxy) и их применение в Node.js.

> **Задача**:
> - Выделить Bounded Context (например, «Пользователи», «Заказы»), описать доменные сущности.
> - Попробовать применить CQRS (отдельный сервис для чтения, отдельный для записи).

---

## **3. Безопасность на уровне эксперта**

### **3.1. Аутентификация и авторизация**

1. **JWT, OAuth2, OpenID Connect**
    - Хранение и ротация токенов, refresh-токены, blacklist.
2. **Роли и права**
    - RBAC (Role-Based Access Control) vs ABAC (Attribute-Based).

> **Задача**:
> - Настроить JWT-аутентификацию для микросервисов, обеспечить автоматическое обновление access-токена.
> - Реализовать роли (admin, user) и разграничение доступа.

---

### **3.2. Защита API от атак**

1. **SQL-инъекции, XSS, CSRF**
    - Использование ORM (sequelize, typeorm, knex) или параметризованных запросов.
    - Helmet, csurf.
2. **Rate Limiting, Anti-DDoS**
    - Cloudflare, NGINX, iptables.
3. **Zero Trust Architecture**
    - Минимально необходимый доступ между сервисами (service-to-service auth).

> **Задача**:
> - Настроить middleware для CSRF, проверить устойчивость к XSS (CSP-заголовки).
> - Реализовать аутентификацию между микросервисами (с помощью JWT или mTLS).

---

### **3.3. Безопасность кода и инфраструктуры**

1. **npm audit, Snyk**
    - Автоматические проверки зависимостей, регулярные обновления.
2. **TLS/HTTPS**
    - Шифрование каналов, настройка сертификатов.
3. **Side-channel атаки**
    - Spectre/Meltdown, общие рекомендации, как Node.js может быть затронут.

> **Задача**:
> - Настроить автоматический аудит зависимостей при каждом пуше.
> - Перейти на HTTPS с собственным сертификатом, добавить HSTS-заголовок.

---

### **3.4. Криптография (Crypto-модуль и PKI)**

1. **Crypto-модуль Node.js**
    - Шифрование (AES), хэширование (SHA, bcrypt), цифровые подписи (RSA, ECDSA).
2. **SSL/TLS**
    - Самостоятельная генерация ключей и сертификатов (OpenSSL), настройка безопасности.
3. **PKI**
    - Свой мини-CA, выдача и отзыв сертификатов.

> **Задача**:
> - Организовать mini-CA (Certificate Authority) для локальных сервисов и проверить взаимную аутентификацию (mTLS).
> - Использовать Crypto-модуль для шифрования конфиденциальных полей (например, номеров карт).

---

## **4. Финальная проверка знаний (Low-Level + Архитектура)**

### **Итоговый челлендж: разработать свой мини-фреймворк**

1. **HTTP-сервер** на чистом `http`-модуле (никаких Express/Fastify).
2. **Middleware-архитектура** (как Koa), чтобы можно было подключать плагины.
3. **Роутинг** с параметрами (например, `/users/:id`).
4. **Обработка асинхронности** (async/await + корректная обработка ошибок).
5. **Использование Streams** (отдача больших файлов).
6. **Система плагинов** (динамическая загрузка модулей).
7. **Глобальная обработка ошибок** (и статус-коды, и логи).
8. **Тесты** (Jest или Mocha) на ключевые роуты/функции.
9. **Производительность** — постарайся в бенчмарках приблизиться или превзойти Express.

> **Задача**:
> - Собрать этот фреймворк в Docker-образ и запустить под нагрузкой (например, через `wrk` или `autocannon`).
> - Оценить метрики (RPS, Latency), профилировать (clinic.js) и оптимизировать, как только возможно.

---

# **ИТОГ**

Пройдя через **все** пункты этого плана, ты освоишь:

1. **Глубокие внутренности Node.js** (V8, Event Loop, libuv, Worker Threads, Streams).
2. **Асинхронность** и её инструменты (Promises, async/await, async_hooks, perf_hooks).
3. **TypeScript** и **продвинутые фишки** Node.js (в т.ч. профилирование и оптимизация).
4. **Архитектуру** (REST, GraphQL, WebSockets, микросервисы, DDD, CQRS) и **CI/CD**.
5. **Docker и Kubernetes** для контейнеризации и оркестрации.
6. **Безопасность** (XSS, CSRF, JWT, PKI, криптография), DevSecOps-подход.
7. **Финальный проект** — собственный мини-фреймворк на Node.js, проверяющий все навыки.
